<script>
let filas = [];
const HEADERS = ["CARRERA","AÑO","CICLO","MATERIA","CÓDIGO","HORAS TEÓRICAS","HORAS PRÁCTICAS","HORAS AUTÓNOMAS","PRERREQUISITO"];

// Ciclos habituales
const CYCLE_WORDS = ["PRIMERO","SEGUNDO","TERCERO","CUARTO","QUINTO","SEXTO","SÉPTIMO","SEPTIMO","OCTAVO","NOVENO","DÉCIMO","DECIMO"];

// Patrones de código (flexibles)
const RE_2019 = /^[A-Z]{2,4}-\d{2,3}-[A-Z0-9]{2,}$/;                 // FT-01-ADM1
const RE_2023 = /^[A-Z]{2,5}(?:\s|-)?\d{2,3}$/;                      // MKT 397, ECN211, TMC-110
const RE_FLEX = /^[A-Z0-9][A-Z0-9\s-]{1,}$/;                         // fallback: incluye 3D-0PE-6A, etc.

function isNumber(v){
  if (v === undefined || v === null) return false;
  if (typeof v === "string" && v.trim() === "") return false;
  return !isNaN(Number(v));
}
function numOrZero(v){ return isNumber(v) ? Number(v) : 0; }

function isCycleText(x){
  if (!x) return false;
  const s = String(x).trim().toUpperCase();
  return CYCLE_WORDS.includes(s);
}
function isForbiddenName(x){
  if (!x) return false;
  const s = String(x).trim().toUpperCase();
  return s === "TOTAL" || s === "TITULACIÓN" || s === "TITULACION";
}
function codigoPasa(code, ht, hp, ha){
  if (!code) return false;
  const s = String(code).trim().toUpperCase();
  if (s === "TOTAL") return false;
  const hasHours = isNumber(ht) || isNumber(hp) || isNumber(ha);
  // Acepta si cumple patrón 2019 o 2023; o si es "flex" pero con horas a la derecha.
  return RE_2019.test(s) || RE_2023.test(s) || (RE_FLEX.test(s) && hasHours);
}

document.getElementById('file').addEventListener('change', (e) => {
  filas = [];
  const file = e.target.files?.[0];
  if (!file) return;

  const carrera = document.getElementById('carrera').value;
  const anio = document.getElementById('anio').value;

  const reader = new FileReader();
  reader.onload = (evt) => {
    const data = new Uint8Array(evt.target.result);
    const wb = XLSX.read(data, { type: 'array' });

    wb.SheetNames.forEach((name) => {
      const sheet = wb.Sheets[name];
      const A = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });

      if (!A || !A.length) return;

      // 1) Detectar fila de ciclos (normalmente fila 0)
      let cyclesRow = 0;
      let foundRow = A.findIndex(r => (r||[]).some(c => isCycleText(c)));
      if (foundRow >= 0) cyclesRow = foundRow;

      // 2) Tomar índices de columnas de ciclo (o fallback cada 5 columnas)
      let cycleCols = [];
      const headerRow = A[cyclesRow] || [];
      for (let j = 0; j < headerRow.length; j++){
        if (isCycleText(headerRow[j])) cycleCols.push({col:j, ciclo:String(headerRow[j]).trim().toUpperCase()});
      }
      if (!cycleCols.length){
        for (let j = 0; j < (A[0]?.length || 0); j += 5){
          cycleCols.push({col:j, ciclo:""});
        }
      }

      // 3) Recorrer cada ciclo y extraer por bloques
      for (const {col, ciclo} of cycleCols){
        let row = cyclesRow + 1;
        while (row < A.length - 1){
          const nombre = (A[row]?.[col] ?? "").toString().trim();
          if (!nombre || isForbiddenName(nombre)){ row++; continue; }

          const code    = (A[row+1]?.[col] ?? "").toString().trim();
          const htCell  = A[row+1]?.[col+1];
          const hpCell  = A[row+1]?.[col+2];
          const haCell  = A[row+1]?.[col+3];

          // Validación robusta: código + horas a la derecha
          if (codigoPasa(code, htCell, hpCell, haCell)){
            filas.push({
              "CARRERA": carrera,
              "AÑO": anio,
              "CICLO": ciclo || String(headerRow[col] ?? "").toUpperCase(),
              "MATERIA": nombre,
              "CÓDIGO": code,
              "HORAS TEÓRICAS": numOrZero(htCell),
              "HORAS PRÁCTICAS": numOrZero(hpCell),
              "HORAS AUTÓNOMAS": numOrZero(haCell),
              "PRERREQUISITO": "" // completar manualmente
            });

            // Saltar bloque: nombre, código(+horas), posible código interno (sin horas), TOTAL
            row += 3; // es suficiente en 2019 y 2023; si hay una fila extra de TOTAL, la saltaremos en el siguiente ciclo natural
          } else {
            row++;
          }
        }
      }
    });

    renderTabla();
  };
  reader.readAsArrayBuffer(file);
});

function renderTabla() {
  const out = document.getElementById('out');
  if (!filas.length) {
    out.innerHTML = "<p style='color:#c00'><b>No se encontraron materias válidas.</b></p>";
    return;
  }
  let html = "<table><thead><tr>";
  html += HEADERS.map(h => `<th>${h}</th>`).join("");
  html += "</tr></thead><tbody>";
  for (const f of filas) {
    html += "<tr>";
    for (const h of HEADERS) html += `<td>${f[h] ?? ""}</td>`;
    html += "</tr>";
  }
  html += "</tbody></table>";
  out.innerHTML = html;
}

document.getElementById('btnExcel').addEventListener('click', () => {
  if (!filas.length) return;
  const data = [HEADERS];
  for (const f of filas) data.push(HEADERS.map(h => (f[h] ?? "")));
  const ws = XLSX.utils.aoa_to_sheet(data);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Malla");
  XLSX.writeFile(wb, "malla_filas.xlsx");
});
</script>
