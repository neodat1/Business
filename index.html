<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Planificación académica – Carga desde Excel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- SheetJS (XLSX) para leer Excel en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --azul:#04136C; --mostaza:#DE912E; --vino:#862B39; --celeste:#9CBEE3; --verde:#8A9520;
    }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,sans-serif;margin:16px;background:#f7f8fb;color:#111}
    h1{font-size:20px;margin:0 0 8px;color:var(--azul)}
    .card{background:#fff;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,.06);padding:14px;margin:10px 0}
    label{font-weight:600}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    input[type="file"]{padding:8px;border:1px solid #ddd;border-radius:8px;background:#fff}
    button{border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
    .btn{background:var(--azul);color:#fff}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .hint{font-size:12px;color:#444}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px;background:#fff}
    thead th{position:sticky;top:0;background:#f0f3ff;color:#0a0e40;border-bottom:2px solid #e5e7f5}
    th,td{border:1px solid #e8e8ee;padding:6px 8px;vertical-align:top}
    .ok{color:#146c2e;font-weight:700}
    .warn{color:#a04900;font-weight:700}
    .err{color:#8b0000;font-weight:700}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef4ff;border:1px solid #dbe5ff;margin-right:6px;font-size:11px}
    .footer{margin-top:6px;font-size:12px;color:#333}
    .log{white-space:pre-wrap;background:#0b102a;color:#e6ecff;border-radius:8px;padding:10px;max-height:200px;overflow:auto}
  </style>
</head>
<body>
  <h1>Planificación académica – Lector de Excel y asignación de horarios</h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="mallas">Mallas.xlsx</label><br/>
        <input id="mallas" type="file" accept=".xlsx,.xls" />
      </div>
      <div>
        <label for="docentes">Docentes.xlsx</label><br/>
        <input id="docentes" type="file" accept=".xlsx,.xls" />
      </div>
      <div style="margin-top:18px">
        <button id="procesar" class="btn">Procesar</button>
      </div>
    </div>
    <div class="footer">
      <span class="pill">Días: Lunes–Viernes</span>
      <span class="pill">Franjas: 7-10 · 10-13 · 13-16 · 16-19 · 19-22</span>
      <span class="pill">≤ 2 asignaturas por día (por grupo)</span>
      <span class="pill">Evitar choques entre ciclos contiguos</span>
    </div>
  </div>

  <div class="card">
    <strong>Estado:</strong> <span id="estado">Listo.</span>
    <div id="log" class="log" style="display:none;margin-top:8px"></div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
      <strong>Resultado (matriz solicitada)</strong>
      <div>
        <button id="descargar" class="btn" disabled>Descargar XLSX</button>
      </div>
    </div>
    <div style="overflow:auto">
      <table id="tabla">
        <thead><tr id="thead"></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
(function(){
  // ======= Configuración base =======
  const DIAS = ["Lunes","Martes","Miércoles","Jueves","Viernes"];
  const FRANJAS = ["7-10","10-13","13-16","16-19","19-22"];
  const HORAS_POR_BLOQUE = 3;

  // Orden y etiquetas exactas de salida (matriz solicitada)
  const HEADERS = [
    "DOCENTE","TITULO ACADÉMICO","DEDICACIÓN","MATERIA","MALLA","CÓDIGO ANTHOLOGY",
    "CARRERAS QUE COMPARTEN","PRE-REQUISITO","CODIGO","HORAS TEÓRICAS","HORAS PRÁCTICAS",
    "HORAS AUTÓNOMAS","CREDITOS","CAMPO DE FORMACIÓN","CICLO MALLA","Nº ORDEN EN LA MALLA",
    "PARALELO","DIA","HORA","MODALIDAD","Nro. HORAS"
  ];

  // Sinónimos de columnas (tolerante a mayúsculas, tildes y variaciones)
  const SYN = {
    DOCENTE: ["docente","profesor","nombre docente","nombre_docente"],
    TITULO: ["titulo academico","título académico","titulo","títulos"],
    DEDICACION: ["dedicacion","dedicación","jornada","tiempo"],
    MALLA: ["malla","plan","pensum"],
    MATERIA: ["materia","asignatura","nombre materia","nombre de la materia","nombre_asignatura"],
    CODIGO: ["codigo","código","cod"],
    CODIGO_ANTHOLOGY: ["codigo anthology","código anthology","anthology","cod anthology","cod. anthology"],
    CARRERAS_COMPARTEN: ["carreras que comparten","carreras comparten","comparten","compartida con"],
    PRERREQ: ["pre-requisito","prerequisito","prerrequisito","requisito","requisitos"],
    HORAS_T: ["horas teoricas","horas teóricas","horas t","ht","teoricas"],
    HORAS_P: ["horas practicas","horas prácticas","horas p","hp","practicas"],
    HORAS_A: ["horas autonomas","horas autónomas","horas a","ha","autonomas"],
    CREDITOS: ["creditos","créditos","cr"],
    CAMPO: ["campo de formacion","campo de formación","area formacion","área formación","área de formación"],
    CICLO: ["ciclo malla","ciclo","semestre","nivel"],
    ORDEN: ["nº orden en la malla","no orden en la malla","orden malla","orden en la malla","orden"],
    PARALELO: ["paralelo","seccion","sección","grupo"],
    DIA: ["dia","día"],
    HORA: ["hora","franja","bloque"],
    MODALIDAD: ["modalidad","modo","presencial/online","tipo"],
    DISPONIBILIDAD: ["disponibilidad","disponible","agenda","horario"],
    CARRERA: ["carrera","programa","escuela"],
  };

  // ======= Utilidades =======
  const norm = s => (s||"").toString()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\s+/g," ").trim().toLowerCase();

  function pick(row, keys){
    // keys: lista de sinónimos (strings)
    const nmap = {};
    Object.keys(row||{}).forEach(k => nmap[norm(k)] = k);
    for(const k of keys){
      const nk = norm(k);
      if(nmap[nk] != null) return row[nmap[nk]];
      // búsqueda contiene
      for(const cand in nmap){ if(cand===nk) continue; if(cand.includes(nk)) return row[nmap[cand]]; }
    }
    return undefined;
  }

  function findKey(obj, keys){
    if(!obj) return null;
    const nmap = {};
    Object.keys(obj).forEach(k => nmap[norm(k)] = k);
    for(const k of keys){ const nk = norm(k); if(nmap[nk]) return nmap[nk]; }
    return null;
  }

  function asNumber(v, def=0){
    if(v==null || v==="") return def;
    const n = parseFloat( (v+"").toString().replace(",",".") );
    return isFinite(n) ? n : def;
  }

  function ensureArray(a){ return Array.isArray(a) ? a : (a==null ? [] : [a]); }

  // ======= Lectura de Excel =======
  async function readWorkbook(file){
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, {type:"array"});
    const rows = [];
    wb.SheetNames.forEach(name=>{
      const sheet = wb.Sheets[name];
      const data = XLSX.utils.sheet_to_json(sheet, {defval:""});
      rows.push(...data);
    });
    return rows;
  }

  // ======= Parseo de Mallas y Docentes =======
  function parseMallas(rows){
    // Devuelve lista de cursos
    return rows.map((r, idx) => {
      const carrera = pick(r, SYN.CARRERA) || "";
      const malla = pick(r, SYN.MALLA) || "";
      const materia = pick(r, SYN.MATERIA) || "";
      const codigo = pick(r, SYN.CODIGO) || "";
      const codAnth = pick(r, SYN.CODIGO_ANTHOLOGY) || "";
      const comparten = pick(r, SYN.CARRERAS_COMPARTEN) || "";
      const prer = pick(r, SYN.PRERREQ) || "";
      const ht = asNumber(pick(r, SYN.HORAS_T), 0);
      const hp = asNumber(pick(r, SYN.HORAS_P), 0);
      const ha = asNumber(pick(r, SYN.HORAS_A), 0);
      const creditos = pick(r, SYN.CREDITOS) || "";
      const campo = pick(r, SYN.CAMPO) || "";
      const ciclo = pick(r, SYN.CICLO) || "";
      const orden = pick(r, SYN.ORDEN) || "";
      const paralelo = pick(r, SYN.PARALELO) || "";
      const modalidad = pick(r, SYN.MODALIDAD) || "";

      // Posibles columnas ya asignadas
      const docente = pick(r, SYN.DOCENTE) || "";

      return {
        id:`C${idx+1}`,
        carrera, malla, materia, codigo, codAnth,
        comparten, prer, ht, hp, ha, creditos, campo, ciclo, orden, paralelo, modalidad,
        docenteAsignado: docente,
        bloquesNecesarios: Math.max(1, Math.ceil( (asNumber(ht)+asNumber(hp)) / HORAS_POR_BLOQUE )),
        asignaciones: [] // {dia, franja}
      };
    }).filter(c => c.materia || c.codigo);
  }

  function parseDocentes(rows){
    const docentes = {}; // nombre -> {titulo, dedicacion, disponibilidad:Set("Lunes|7-10")}
    const porCodigo = {}; // codigo -> [docente]
    const porMateria = {}; // materia -> [docente]

    function pushIndex(map, key, val){
      if(!key) return;
      const k = norm(key);
      if(!map[k]) map[k] = [];
      if(!map[k].includes(val)) map[k].push(val);
    }

    rows.forEach((r, i) => {
      const nombre = (pick(r, SYN.DOCENTE) || "").toString().trim();
      if(!nombre) return;

      const titulo = pick(r, SYN.TITULO) || "";
      const dedicacion = pick(r, SYN.DEDICACION) || "";
      const materia = pick(r, SYN.MATERIA) || "";
      const codigo = pick(r, SYN.CODIGO) || "";

      if(!docentes[nombre]) docentes[nombre] = {
        titulo, dedicacion, disponibilidad:new Set()
      };

      // Índices de asignación por código/materia (opcional)
      if(codigo) pushIndex(porCodigo, codigo, nombre);
      if(materia) pushIndex(porMateria, materia, nombre);

      // Disponibilidad en formato largo: columnas "DIA" + "FRANJA/HORA"
      const kDia = findKey(r, SYN.DIA);
      const kFra = findKey(r, SYN.HORA) || findKey(r, SYN.DIA.concat(SYN.HORA)); // fallback
      if(kDia && kFra){
        const diaVal = (r[kDia]||"").toString().trim();
        const franjaVal = (r[kFra]||"").toString().trim();
        if(diaVal && franjaVal){
          const d = normalizaDia(diaVal);
          const f = normalizaFranja(franjaVal);
          if(d && f) docentes[nombre].disponibilidad.add(keySlot(d,f));
        }
      }

      // Disponibilidad en formato ancho: columnas tipo "Lunes 7-10", "Martes_10-13", etc.
      Object.keys(r).forEach(col=>{
        const val = (r[col]??"").toString().trim();
        if(!val) return;
        const ncol = norm(col);
        const d = DIAS.find(d=> ncol.includes(norm(d)) );
        const f = FRANJAS.find(f=> ncol.includes(norm(f)) || ncol.includes(norm(f.replace("-","_"))) );
        if(d && f){
          // Interpretar cualquier valor no vacío como disponible (X, 1, ok, sí)
          if(/^(x|1|ok|si|sí|true)$/i.test(val) || val.length>0){
            docentes[nombre].disponibilidad.add(keySlot(d,f));
          }
        }
      });

      // Disponibilidad en texto libre: columna "Disponibilidad" (e.g., "Lunes 7-10; Mie 10-13")
      const dispTxt = pick(r, SYN.DISPONIBILIDAD);
      if(dispTxt){
        dispTxt.toString().split(/[,;]+/).map(s=>s.trim()).forEach(tok=>{
          if(!tok) return;
          let d=null, f=null;
          for(const dia of DIAS){ if(tok.toLowerCase().includes(norm(dia))){ d=dia; break; } }
          for(const fr of FRANJAS){ if(tok.replace("_","-").includes(fr)){ f=fr; break; } }
          if(d && f) docentes[nombre].disponibilidad.add(keySlot(d,f));
        });
      }
    });

    return {docentes, porCodigo, porMateria};
  }

  function keySlot(dia, franja){ return `${dia}|${franja}`; }
  function normalizaDia(x){
    const t = norm(x);
    if(t.startsWith("lun")) return "Lunes";
    if(t.startsWith("mar")) return "Martes";
    if(t.startsWith("mie") || t.startsWith("mié")) return "Miércoles";
    if(t.startsWith("jue")) return "Jueves";
    if(t.startsWith("vie")) return "Viernes";
    return null;
  }
  function normalizaFranja(x){
    const z = x.toString().replace(/\s/g,"").replace("_","-");
    for(const f of FRANJAS){ if(z.includes(f.replace("-","-"))) return f; }
    // También aceptar "07-10", "7–10", "7 a 10", etc.
    const m = z.match(/(\d{1,2}).*?(\d{1,2})/);
    if(m){
      const a = m[1].padStart(1,"0"), b=m[2].padStart(1,"0");
      const cand=`${a}-${b}`.replace(/^0/,"");
      if(FRANJAS.includes(cand)) return cand;
    }
    return null;
  }

  // ======= Programación de horarios =======
  function programar(cursos, idxDoc){
    const {docentes, porCodigo, porMateria} = idxDoc;

    // Estructuras para evitar choques
    const grKey = c => `${norm(c.carrera)}|${norm(c.ciclo)}|${norm(c.paralelo)}`;
    const groupDayCount = {};   // key -> {Lunes: n, ...} (máx 2 por día)
    const groupGrid = {};       // key -> Set("Lunes|7-10")
    const docenteGrid = {};     // docente -> Set("Lunes|7-10")

    function getGroupSet(g){ if(!groupGrid[g]) groupGrid[g]=new Set(); return groupGrid[g]; }
    function getGroupDay(g){ if(!groupDayCount[g]) groupDayCount[g] = Object.fromEntries(DIAS.map(d=>[d,0])); return groupDayCount[g]; }
    function getDocSet(d){ if(!docenteGrid[d]) docenteGrid[d]=new Set(); return docenteGrid[d]; }

    // índice por (carrera,ciclo,paralelo) para chequear adyacencias
    const groupsByCarreraCiclo = {};
    cursos.forEach(c=>{
      const k = `${norm(c.carrera)}|${norm(c.ciclo)}`;
      if(!groupsByCarreraCiclo[k]) groupsByCarreraCiclo[k]=[];
      const g = grKey(c);
      if(!groupsByCarreraCiclo[k].includes(g)) groupsByCarreraCiclo[k].push(g);
    });

    function vecinosDelCurso(curso){
      // Ciclos contiguos dentro de misma carrera (N-1 y N+1)
      const n = parseInt((curso.ciclo||"").toString().match(/\d+/)?.[0]||"",10);
      if(!isFinite(n)) return [];
      const carr = norm(curso.carrera);
      const gPrev = `${carr}|${norm((n-1).toString())}|${norm(curso.paralelo)}`;
      const gNext = `${carr}|${norm((n+1).toString())}|${norm(curso.paralelo)}`;
      return [gPrev,gNext];
    }

    // Ordenar cursos: primero los que más bloques requieren (greedy)
    cursos.sort((a,b)=> b.bloquesNecesarios - a.bloquesNecesarios);

    const log = [];

    for(const c of cursos){
      const g = grKey(c);
      getGroupSet(g); getGroupDay(g);

      // Determinar docente
      let docente = (c.docenteAsignado||"").trim();
      if(!docente){
        const candidatos =
          (c.codigo && porCodigo[norm(c.codigo)]) ||
          (c.materia && porMateria[norm(c.materia)]) || [];
        docente = candidatos[0] || "";
      }
      c.docenteAsignado = docente;

      // Info docente
      let dTitulo="", dDedic="";
      let disp = null; // Set de slots permitidos
      if(docente && idxDoc.docentes[docente]){
        dTitulo = idxDoc.docentes[docente].titulo || "";
        dDedic = idxDoc.docentes[docente].dedicacion || "";
        disp = idxDoc.docentes[docente].disponibilidad;
      }

      let bloquesAsignados = 0;
      const vecinos = vecinosDelCurso(c);

      outer:
      for(const dia of DIAS){
        // Cumplir "máximo 2 asignaturas por día" por grupo (carrera-ciclo-paralelo)
        if(getGroupDay(g)[dia] >= 2) continue;

        for(const franja of FRANJAS){
          if(bloquesAsignados >= c.bloquesNecesarios) break outer;

          const slot = keySlot(dia, franja);

          // Si hay docente, verificar disponibilidad
          if(docente && disp && disp.size>0 && !disp.has(slot)) continue;

          // Evitar choque del grupo (mismo ciclo-paralelo)
          if(getGroupSet(g).has(slot)) continue;

          // Evitar choque del docente
          if(docente){
            if(getDocSet(docente).has(slot)) continue;
          }

          // Evitar choques con ciclos vecinos (contiguos) de la misma carrera
          let choqueVecino = false;
          for(const vg of vecinos){
            if(groupGrid[vg]?.has(slot)){ choqueVecino = true; break; }
          }
          if(choqueVecino) continue;

          // Cumplir "máximo 2 asignaturas por día" tras asignar
          const cnt = getGroupDay(g)[dia];
          if(cnt >= 2) continue;

          // Asignar
          c.asignaciones.push({dia, franja});
          getGroupSet(g).add(slot);
          getGroupDay(g)[dia] = cnt + 1;
          if(docente) getDocSet(docente).add(slot);

          bloquesAsignados++;
        }
      }

      const asignadas = c.asignaciones.length;
      if(asignadas < c.bloquesNecesarios){
        log.push(`⚠️ ${c.materia || c.codigo}: No se pudo asignar ${c.bloquesNecesarios - asignadas} bloque(s) por restricciones de disponibilidad/choques.`);
      }

      // Adjuntar título/dedicación al curso para salida
      c.tituloDocente = dTitulo;
      c.dedicacionDocente = dDedic;
      c.nroHoras = c.asignaciones.length * HORAS_POR_BLOQUE;
    }

    return {cursos, log};
  }

  // ======= Construcción de matriz y UI =======
  function construirSalida(cursos, todasMallas){
    // Para "Nº ORDEN EN LA MALLA (por carrera /)" si comparten:
    const indexOrdenPorCarrera = {};
    (todasMallas||[]).forEach(r=>{
      const carrera = (pick(r, SYN.CARRERA) || "").toString().trim();
      const materia = (pick(r, SYN.MATERIA) || "").toString().trim();
      const orden = (pick(r, SYN.ORDEN) || "").toString().trim();
      if(!carrera || !materia || !orden) return;
      const key = `${norm(carrera)}|${norm(materia)}`;
      if(!indexOrdenPorCarrera[key]) indexOrdenPorCarrera[key] = new Set();
      indexOrdenPorCarrera[key].add(orden);
    });

    const filas = cursos.map(c=>{
      // DIA / HORA: concatenar asignaciones
      const dias = c.asignaciones.map(a=>a.dia).join(" / ");
      const horas = c.asignaciones.map(a=>a.franja).join(" / ");

      // Orden por carrera (si comparten)
      let ordenPorCarrera = c.orden || "";
      const carrerasComp = (c.comparten||"").toString().split(/[\/;,]+/).map(s=>s.trim()).filter(Boolean);
      if(carrerasComp.length>0){
        const ords = [];
        for(const car of carrerasComp){
          const k = `${norm(car)}|${norm(c.materia)}`;
          const set = indexOrdenPorCarrera[k];
          if(set && set.size>0) ords.push(`${car}:${Array.from(set).join(",")}`);
        }
        if(ords.length>0) ordenPorCarrera = ords.join(" / ");
      }

      const row = {
        "DOCENTE": c.docenteAsignado || "",
        "TITULO ACADÉMICO": c.tituloDocente || "",
        "DEDICACIÓN": c.dedicacionDocente || "",
        "MATERIA": c.materia || "",
        "MALLA": c.malla || "",
        "CÓDIGO ANTHOLOGY": c.codAnth || "",
        "CARRERAS QUE COMPARTEN": c.comparten || "",
        "PRE-REQUISITO": c.prer || "",
        "CODIGO": c.codigo || "",
        "HORAS TEÓRICAS": c.ht ?? "",
        "HORAS PRÁCTICAS": c.hp ?? "",
        "HORAS AUTÓNOMAS": c.ha ?? "",
        "CREDITOS": c.creditos ?? "",
        "CAMPO DE FORMACIÓN": c.campo ?? "",
        "CICLO MALLA": c.ciclo ?? "",
        "Nº ORDEN EN LA MALLA": ordenPorCarrera,
        "PARALELO": c.paralelo ?? "",
        "DIA": dias,
        "HORA": horas,
        "MODALIDAD": c.modalidad ?? "",
        "Nro. HORAS": c.nroHoras ?? 0
      };
      return row;
    });

    return filas;
  }

  function renderTable(headers, rows){
    const thead = document.getElementById("thead");
    const tbody = document.getElementById("tbody");
    thead.innerHTML = ""; tbody.innerHTML = "";
    headers.forEach(h=>{
      const th = document.createElement("th");
      th.textContent = h;
      thead.appendChild(th);
    });
    rows.forEach(r=>{
      const tr = document.createElement("tr");
      headers.forEach(h=>{
        const td = document.createElement("td");
        td.textContent = (r[h]!=null ? r[h] : "");
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }

  function descargarXLSX(headers, rows){
    const ws = XLSX.utils.json_to_sheet(rows, {header: headers});
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Planificación");
    XLSX.writeFile(wb, "planificacion_academica.xlsx");
  }

  // ======= Eventos UI =======
  const $m = document.getElementById("mallas");
  const $d = document.getElementById("docentes");
  const $proc = document.getElementById("procesar");
  const $estado = document.getElementById("estado");
  const $log = document.getElementById("log");
  const $btnDesc = document.getElementById("descargar");

  $proc.addEventListener("click", async ()=>{
    try{
      $btnDesc.disabled = true;
      $estado.textContent = "Procesando archivos…";
      $log.style.display="none"; $log.textContent="";

      const fM = $m.files?.[0];
      const fD = $d.files?.[0];
      if(!fM || !fD){ $estado.innerHTML = '<span class="err">Cargue ambos archivos: Mallas.xlsx y Docentes.xlsx.</span>'; return; }

      const [rowsM, rowsD] = await Promise.all([readWorkbook(fM), readWorkbook(fD)]);

      const cursos = parseMallas(rowsM);
      const idxDoc = parseDocentes(rowsD);

      if(cursos.length===0){
        $estado.innerHTML = '<span class="err">No se detectaron cursos en Mallas.xlsx.</span>';
        renderTable(HEADERS, []);
        return;
      }

      const {cursos: cursosProg, log} = programar(cursos, idxDoc);
      const salida = construirSalida(cursosProg, rowsM);

      renderTable(HEADERS, salida);
      $estado.innerHTML = `<span class="ok">Listo: ${salida.length} filas generadas.</span>` + (log.length? ` <span class="warn">Avisos: ${log.length}</span>`:"");
      if(log.length){
        $log.style.display="block";
        $log.textContent = log.join("\n");
      }
      $btnDesc.disabled = false;

      // Guardar en memoria para descarga
      $btnDesc.onclick = ()=> descargarXLSX(HEADERS, salida);

    }catch(err){
      console.error(err);
      $estado.innerHTML = `<span class="err">Error: ${err.message||err}</span>`;
    }
  });

})();
</script>
</body>
</html>
